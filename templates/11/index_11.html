<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 11: WebXR</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@5.1.0/dist/aframe-event-set-component.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@1.0.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@7.5.4/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-physics-system@4.0.1/dist/aframe-physics-system.min.js"></script>
    <script src="https://gftruj.github.io/hand.tracking.controls.extras/dist/aframe-hand-tracking-controls-extras.js"></script>
</head>
<body>
    <script>
        // Shaders
        AFRAME.registerShader('1', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    float angle = atan(vUv.y - 0.5, vUv.x - 0.5) * 20.0;
                    float radius = length(vUv - vec2(0.5));
                    float pattern = sin(angle + time * 0.005) * cos(radius * 25.0 + time * 0.005);
                    vec3 color1 = vec3(0.8, 0.2, 0.5) * sin(time * 0.003 + pattern);
                    vec3 color2 = vec3(0.2, 0.8, 0.5) * cos(time * 0.003 - pattern);
                    vec3 finalColor = mix(color1, color2, 0.5 + 0.5 * sin(time * 0.003));
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        // Shader 2: Spiral Kaleidoscope
        AFRAME.registerShader('2', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float spiral = sin(10.0 * (r + a + time * 0.01));
                    vec3 color = vec3(0.5 + 0.5 * spiral, 0.5 + 0.5 * cos(spiral), 0.5 + 0.5 * sin(spiral));
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 3: Radial Kaleidoscope
        AFRAME.registerShader('3', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float radial = sin(10.0 * r + time * 0.01);
                    vec3 color = vec3(0.5 + 0.5 * radial, 0.5 + 0.5 * cos(radial), 0.5 + 0.5 * sin(radial));
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 4: Fractal Kaleidoscope
        AFRAME.registerShader('4', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float fractal = sin(10.0 * r + time * 0.01) * cos(10.0 * a + time * 0.01);
                    vec3 color = vec3(0.5 + 0.5 * fractal, 0.5 + 0.5 * cos(fractal), 0.5 + 0.5 * sin(fractal));
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 5: Wave Kaleidoscope
        AFRAME.registerShader('5', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float wave = sin(10.0 * r + time * 0.01) * cos(10.0 * a + time * 0.01);
                    vec3 color = vec3(0.5 + 0.5 * wave, 0.5 + 0.5 * cos(wave), 0.5 + 0.5 * sin(wave));
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 6: Espejo Fractal
        AFRAME.registerShader('6', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float fractal = sin(10.0 * r + time * 0.01) * cos(10.0 * a + time * 0.01);
                    vec3 color = vec3(
                        0.5 + 0.5 * fractal,
                        0.5 + 0.5 * cos(fractal + time * 0.02),
                        0.5 + 0.5 * sin(fractal + time * 0.03)
                    );
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 7: Vortex de Colores
        AFRAME.registerShader('7', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float vortex = sin(10.0 * r + time * 0.01) * cos(10.0 * a + time * 0.01);
                    vec3 color = vec3(
                        0.5 + 0.5 * sin(vortex + time * 0.01),
                        0.5 + 0.5 * cos(vortex + time * 0.02),
                        0.5 + 0.5 * sin(vortex + time * 0.03)
                    );
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 8: Espejo Caleidosc√≥pico
        AFRAME.registerShader('8', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float mirror = sin(10.0 * r + time * 0.01) * cos(10.0 * a + time * 0.01);
                    vec3 color = vec3(
                        0.5 + 0.5 * sin(mirror + time * 0.01),
                        0.5 + 0.5 * cos(mirror + time * 0.02),
                        0.5 + 0.5 * sin(mirror + time * 0.03)
                    );
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 9: Liminal Space
        AFRAME.registerShader('9', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float liminal = sin(10.0 * r + time * 0.01) * cos(10.0 * a + time * 0.01);
                    vec3 color = vec3(
                        0.5 + 0.5 * sin(liminal + time * 0.01),
                        0.5 + 0.5 * cos(liminal + time * 0.02),
                        0.5 + 0.5 * sin(liminal + time * 0.03)
                    );
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Shader 10: AR Espejo
        AFRAME.registerShader('10', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 p = vUv - vec2(0.5);
                    float r = length(p);
                    float a = atan(p.y, p.x);
                    float arMirror = sin(10.0 * r + time * 0.01) * cos(10.0 * a + time * 0.01);
                    vec3 color = vec3(
                        0.5 + 0.5 * sin(arMirror + time * 0.01),
                        0.5 + 0.5 * cos(arMirror + time * 0.02),
                        0.5 + 0.5 * sin(arMirror + time * 0.03)
                    );
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        // Shader 11: Neon Vortex
        AFRAME.registerShader('11', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
            `,
            fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec2 p = vUv - 0.5;
                float angle = atan(p.y, p.x) + time * 0.05;
                float radius = length(p);
                float glow = sin(radius * 20.0 - time * 0.1) * cos(angle * 10.0);
                vec3 color = vec3(0.8 + 0.2 * glow, 0.2 + 0.8 * cos(glow * 2.0), 0.3 + 0.7 * sin(glow * 3.0));
                gl_FragColor = vec4(color, 1.0);
            }
            `
        });

        // Shader 12: Galactic Feathers
        AFRAME.registerShader('12', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
            `,
            fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec2 p = vUv * 2.0 - 1.0;
                float wave = sin(p.x * 15.0 + time * 0.1) * cos(p.y * 15.0 + time * 0.1);
                float feather = smoothstep(0.3, 0.7, wave);
                vec3 color = vec3(0.2 + 0.8 * feather, 0.4 + 0.6 * cos(feather * 2.0), 0.6 + 0.4 * sin(feather * 3.0));
                gl_FragColor = vec4(color, 1.0);
            }
            `
        });

        // Shader 13: Star Explosion
        AFRAME.registerShader('13', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
            `,
            fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec2 p = vUv - 0.5;
                float r = length(p);
                float a = atan(p.y, p.x);
                float explosion = sin(r * 30.0 - time * 0.2) * cos(a * 20.0);
                vec3 color = vec3(0.5 + 0.5 * explosion, 0.5 + 0.5 * cos(explosion * 3.0), 0.5 + 0.5 * sin(explosion * 5.0));
                gl_FragColor = vec4(color, 1.0);
            }
            `
        });

        // Shader 14: Cosmic Peacock
        AFRAME.registerShader('14', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
            `,
            fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec2 p = vUv * 2.0 - 1.0;
                float pattern = sin(p.x * 10.0 + time * 0.1) * cos(p.y * 20.0 - time * 0.2);
                vec3 color = vec3(0.3 + 0.7 * pattern, 0.5 + 0.5 * sin(pattern * 4.0), 0.2 + 0.8 * cos(pattern * 3.0));
                gl_FragColor = vec4(color, 1.0);
            }
            `
        });

        // Shader 15: Diamond Nebula
        AFRAME.registerShader('15', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
            `,
            fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec2 p = vUv * 2.0 - 1.0;
                float diamond = abs(sin(p.x * 25.0 + time * 0.1) * cos(p.y * 25.0 - time * 0.1));
                vec3 color = vec3(0.6 + 0.4 * diamond, 0.3 + 0.7 * cos(diamond * 2.0), 0.8 + 0.2 * sin(diamond * 3.0));
                gl_FragColor = vec4(color, 1.0);
            }
            `
        });
        /* celestial-vortex */
        AFRAME.registerShader('16', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vPosition;

                void main() {
                    vec3 p = normalize(vPosition);
                    float angle = atan(p.y, p.x) + sin(time * 0.1) * 0.5;
                    float radius = length(p);
                    float waves = sin(radius * 15.0 - time * 0.2) * cos(angle * 10.0);
                    vec3 color = vec3(0.3 + 0.7 * waves, 0.6 + 0.4 * cos(waves * 2.0), 0.9 + 0.1 * sin(waves * 3.0));
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        /* starfield-hyperspace */
        AFRAME.registerShader('17', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vPosition;

                void main() {
                    vec3 p = normalize(vPosition);
                    float angle = atan(p.y, p.x) + sin(time * 0.1) * 0.5;
                    float radius = length(p);
                    float waves = sin(radius * 15.0 - time * 0.2) * cos(angle * 10.0);
                    vec3 color = vec3(0.3 + 0.7 * waves, 0.6 + 0.4 * cos(waves * 2.0), 0.9 + 0.1 * sin(waves * 3.0));
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        AFRAME.registerShader('18', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vPosition;

                void main() {
                    vec3 p = normalize(vPosition);
                    float noise = fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);
                    float nebula = sin(time * 0.05 + noise * 15.0) * 0.5 + 0.5;
                    vec3 color = mix(vec3(0.1, 0.0, 0.3), vec3(1.0, 0.5, 0.2), nebula);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        /* ocean-depths */
        AFRAME.registerShader('19', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vPosition;

                void main() {
                    vec3 p = normalize(vPosition);
                    float depth = sin(p.y * 5.0 + time * 0.1) * 0.1;
                    float light = smoothstep(0.3, 1.0, sin(time * 0.1 + p.y * 10.0));
                    vec3 color = vec3(0.0, 0.3 + depth, 0.6 + light * 0.5);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        /* flowing-blood */
        AFRAME.registerShader('20', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vPosition;

                void main() {
                    vec3 p = normalize(vPosition);
                    float pulse = sin(time * 0.2 + p.y * 10.0) * 0.1;
                    vec3 color = vec3(0.5 + pulse, 0.0, 0.0);
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
        AFRAME.registerShader('21', {
            schema: {
                time: { type: 'time', is: 'uniform' },
                speed: { type: 'number', default: 1.0, is: 'uniform' }
            },
            vertexShader: `
                varying vec3 vPosition;
                varying vec3 vNormal;
                void main() {
                    vPosition = position;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform float speed;
                varying vec3 vPosition;
                varying vec3 vNormal;

                // Funci√≥n de ruido para generar texturas org√°nicas
                float noise(vec3 p) {
                    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453;
                }

                // Funci√≥n para generar estrellas
                float stars(vec3 p) {
                    vec3 starPos = fract(p * 100.0) - 0.5;
                    float star = smoothstep(0.45, 0.5, length(starPos));
                    return star;
                }

                // Funci√≥n para generar nebulosas
                vec3 nebulae(vec3 p) {
                    float n1 = noise(p * 0.5 + time * 0.1 * speed);
                    float n2 = noise(p * 1.0 + time * 0.2 * speed);
                    float n3 = noise(p * 2.0 + time * 0.3 * speed);
                    return vec3(n1, n2, n3) * 0.5 + 0.5;
                }

                // Funci√≥n para generar el v√≥rtice central
                float vortex(vec3 p) {
                    float radius = length(p.xy);
                    float angle = atan(p.y, p.x) + time * 0.2 * speed;
                    float distortion = sin(radius * 10.0 - time * 0.5 * speed) * 0.1;
                    return smoothstep(0.1, 0.5, radius + distortion);
                }

                void main() {
                    vec3 p = normalize(vPosition);
                    vec3 color = vec3(0.0);

                    // Estrellas
                    float starField = stars(p * 10.0);
                    color += starField * vec3(1.0, 1.0, 1.0);

                    // Nebulosas
                    vec3 nebulaColor = nebulae(p * 2.0);
                    color += nebulaColor * vec3(0.3, 0.1, 0.5);

                    // V√≥rtice central
                    float vortexEffect = vortex(p);
                    color = mix(color, vec3(0.0, 0.0, 0.0), vortexEffect);

                    // A√±adir profundidad con la normal
                    float depth = dot(vNormal, vec3(0.0, 0.0, 1.0));
                    color *= depth * 0.5 + 0.5;

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        AFRAME.registerShader('22', {
            schema: { time: { type: 'time', is: 'uniform' } },
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec3 vPosition;

                float noise(vec3 p) {
                    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453;
                }

                void main() {
                    vec3 p = normalize(vPosition);
                    float angle = atan(p.y, p.x) + sin(time * 0.1) * 0.5;
                    float radius = length(p);
                    float waves = sin(radius * 15.0 - time * 0.2) * cos(angle * 10.0);
                    vec3 color = vec3(0.3 + 0.7 * waves, 0.6 + 0.4 * cos(waves * 2.0), 0.9 + 0.1 * sin(waves * 3.0));
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });
    </script>

    <a-scene vr-mode-ui="enabled: true" background="color: black" physics="debug: true">
        <!-- Esfera con shaders (usando side: double) -->
        <a-entity id="esfera" geometry="primitive: sphere; radius: 500" material="shader: 1; side: double"></a-entity>

        <!-- Fragmentos de cristal -->
        <script>
            const shaders = ['22', '21', '20', '19', '18', '17', '16', '15', '14', '13', '12', '11', '10', '9', '8', '7', '6', '5', '4', '3', '2', '1'];
            let currentIndex = 0;

            function changeShader() {
                const esfera = document.getElementById('esfera');
                if (esfera) {
                    esfera.setAttribute('material', 'shader', shaders[currentIndex]);
                    currentIndex = (currentIndex + 1) % shaders.length;
                }
            }

            setInterval(changeShader, 6000);
        </script>

            <a-entity id="cubo" geometry="primitive: box" material="shader: 1" position="0 1.6 -3" rotation="0 45 0" dynamic-body="mass: 2; linearDamping: 0.1; angularDamping: 0.1" grabbable>

            <a-animation attribute="rotation"
                         dur="10000"
                         repeat="indefinite"
                         to="0 405 0"
                         easing="linear">
            </a-animation>
        </a-entity>


        <a-entity id="rightHand" hand-controls="hand: right" laser-controls="hand: right">

            <a-entity id="grabPoint" position="0 0 -0.1" visible="false"></a-entity>
        </a-entity>

        <!-- Luces -->
        <a-entity light="type: ambient; intensity: 1"></a-entity>
        <a-entity light="type: point; intensity: 2; color: #FF00FF" position="3 5 2"></a-entity>
        <a-entity light="type: point; intensity: 2; color: #00FFFF" position="-3 -5 -2"></a-entity>

        <!-- C√°mara y controles VR -->
        <a-entity camera look-controls wasd-controls position="0 1.6 0">
            <a-entity id="leftHand" hand-controls="hand: left" laser-controls="hand: left"></a-entity>
            <a-entity id="rightHand" hand-controls="hand: right" laser-controls="hand: right"></a-entity>
        </a-entity>
    </a-scene>
    <script>
        // Movimiento con joysticks del Meta Quest
        const camera = document.querySelector('[camera]');
        const movementSpeed = 0.1;

        document.querySelector('a-scene').addEventListener('thumbstickmoved', (event) => {
            const { x, y } = event.detail;
            const direction = new THREE.Vector3(x, 0, -y).normalize();
            camera.setAttribute('position', {
                x: camera.getAttribute('position').x + direction.x * movementSpeed,
                y: camera.getAttribute('position').y + direction.y * movementSpeed,
                z: camera.getAttribute('position').z + direction.z * movementSpeed
            });
        });
    </script>
    <script>

        const cubo = document.getElementById('cubo');
        const grabPoint = document.getElementById('grabPoint');
        let isGrabbing = false;

        document.getElementById('rightHand').addEventListener('gripdown', () => {
            if (!isGrabbing) {

                cubo.setAttribute('dynamic-body', 'mass: 0');
                cubo.setAttribute('position', grabPoint.getAttribute('position'));
                cubo.setAttribute('constraint', 'target: #grabPoint; type: lock');
                isGrabbing = true;
            }
        });

        document.getElementById('rightHand').addEventListener('gripup', () => {
            if (isGrabbing) {

                cubo.removeAttribute('constraint');
                cubo.setAttribute('dynamic-body', 'mass: 2');
                isGrabbing = false;
            }
        });
    </script>

</body>
</html>